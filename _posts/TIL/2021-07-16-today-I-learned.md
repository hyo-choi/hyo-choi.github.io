---
layout: post
title: "[TIL] 웹소켓, EventSource, 쿠키, 웹 스토리지"
categories: [TIL]
tags: [TIL, JavaScript, WebSocket, EventSource, Cookie, WebStorage]
comment: true
---

# Today I Learned

2021/07/16

<br>

# 네트워크 요청

## [웹소켓](https://ko.javascript.info/websocket)

- 웹소켓은 RFC에 정의되어있는 프로토콜이다. ws라는 scheme을 사용하며, HTTP-HTTPS의 관계와 유사한 ws-wss 관계를 가지고 있다.
- **웹소켓 프로토콜은 항상 wss를 사용**해야 한다. ws는 데이터를 암호화하지 않기 때문에 아주 오래된 프락시 서버에서는 웹소켓 헤더를 '이상한' 헤더로 판단해 연결을 끊을 수도 있으나, wss는 TSL 계층을 통해 전달되어 데이터 패킷이 암호화된 상태로 프락시 서버를 통과하므로 프락시 서버가 패킷 내부를 볼 수 없어 데이터가 안전하게 전달된다.
- `new WebSocket("wss://...");` 를 통해 소켓이 정상적으로 만들어지면 **open/message/error/close**의 네 가지 이벤트를 사용할 수 있게 된다.
- 소켓 객체를 생성하면 즉시 연결이 시작되며, 최초 요청 시 서버가 웹소켓을 지원한다는 응답(101 Switching Protocols)을 한다면 서버-브라우저간 통신은 HTTP 대신 웹소켓 프로토콜을 사용해 데이터가 전송된다. 이를 **웹소켓 핸드셰이크**라고 한다.
- 웹소켓 객체는 기본적으로 **cross-origin 요청을 지원**한다.
- `socket.send(data)` 메서드로 텍스트나 바이너리 데이터를 보낼 수 있다. data는 string이거나 Blob, ArrayBuffer와 같은 바이너리 데이터, 혹은 그 외의 것일 수 있다. 별도의 처리 없이 아무 타입으로 보내도 전송된다.
- 데이터를 받을 때에는 `socket.onmessage` 이벤트 핸들러를 이용하고, `socket.binaryType` 프로퍼티의 설정값(기본값은 "Blob")을 변경하면 바이너리 응답을 어떤 객체로 반환받을지 선택할 수 있다.
    - Blob은 `<a>`, `<img>` 등의 태그를 통합하는 고수준 바이너리 객체이므로 기본으로 사용되지만, 만약 데이터에 직접 접근하고 싶다면 arraybuffer를 사용할 수 있다.
- 웹소켓을 닫을 때는 `socket.close([code], [reason])` 메서드를 사용하는데, 두 인자 모두 optional하다. [웹소켓을 위한 종료 코드](https://tools.ietf.org/html/rfc6455#section-7.4.1)는 1000번 이상의 값을 사용한다. 만약 close에서 code가 인자로 주어지지 않았다면 1000번 코드를 사용하게 된다.
- `socket.readyState` 프로퍼티를 사용하면 연결 상태를 알 수 있다.
    - 0: "CONNECTING"
    - 1: "OPEN"
    - 2: "CLOSING"
    - 3: "CLOSED"

<br>

## [Server-sent events](https://developer.mozilla.org/en-US/docs/Web/API/Server-sent_events), [EventSource](https://developer.mozilla.org/ko/docs/Web/API/EventSource)

- server-sent 이벤트는 **웹소켓과 다르게 단방향**이다. EventSource는 소셜 미디어 상태 업데이트, 뉴스피드, IndexedDB, web storage처럼 클라이언트로 데이터를 전달하는 데 유용하다.
- 웹소켓은 간단한 어플리케이션에 사용하기에는 성능이 조금 과한 면이 있다. 따라서 보다 **심플한 EventSource**를 사용하기도 한다.
- EventSource는 오래 된 일반 HTTP 프로토콜이고 새로운 프로토콜이 아니므로 구식 브라우저에서도 동작한다. 또, 웹소켓에서는 auto-reconnect를 자체 구현해야하는데 반해 EventSource는 이를 지원한다.
- `new EventSource("https://...");` 를 사용하면 서버에 연결되고, **open/message/error**의 기본 이벤트를 사용할 수 있게 된다.
- 서버의 응답은 data, id, retry, event 필드를 가질 수 있다. 보통 id가 가장 마지막에 자리한다.
    - 응답**에 특정한 event를 함께 보내려면** 이벤트가 시작될 때 `event: event-name` 을 함께 보낼 수 있다. 해당 이벤트를 캐치하려면 클라이언트 단에서 addEventListener를 사용해주면 된다.
    - EventSource는 연결이 망가지면 자동으로 재연결한다. 서버는 응답의 retry 헤더를 수정하여 재연결시 딜레이를 조정할 수 있다.
- EventSource 또한 기본적으로 **cross-origin 요청을 지원**한다.
- `EventSource.readyState` 프로퍼티를 사용하면 연결 상태를 알 수 있다.
    - 0: "CONNECTING"
    - 1: "OPEN"
    - 2: "CLOSED"

<br>

# 브라우저에 데이터 저장하기

## [쿠키](https://ko.javascript.info/cookie)

### General

- 쿠키는 **브라우저에 저장되는 작은 크기의 문자열**이다. 주로 웹 서버에 의해 만들어지며, 서버가 HTTP 응답의 Set-Cookie 헤더에 내용을 넣어 전달하면 브라우저가 이 내용을 **자체적으로 브라우저에 저장**한다. 클라이언트 식별과 같은 인증에 가장 많이 쓰인다.
- 브라우저는 사용자가 쿠키를 생성하도록 한 **동일 서버에 접속할 때마다** HTTP 요청에 Cookie 헤더를 함께 넣어 전달한다.
- 쿠키 하나가 차지하는 용량은 **최대 4KB**이고, 사이트 하나 당 약 20여 개의 쿠키를 허용하나 이 수치는 브라우저에 따라 상이하다.
- 쿠키를 갱신하거나 삭제할 때에는 **쿠키를 설정할 때 지정했던 도메인이나 경로**를 사용해야 한다.

<br>

### GDPR

- EU에는 사용자 개인 정보 보호를 강제하는 법령인 **GDPR**General Data Protection Regulation이 있는데, 쿠키를 추적하는 경우 사용자로부터 명시적인 허가를 얻어야 한다는 것이 그 중요 요건 중 하나다. 2018년 5월 발효되었다. 최근 인터넷에서 쿠키 저장 허가 요청 UI를 종종 마주치게 된 것이 이 법령 때문이다.
    - 따라서 사용자가 EU 국가 거주자인 경우 반드시 GDPR을 준수해야 한다.
    - GDPR은 쿠키에 대해서만 다루는 것이 아니라 전반적인 보안 이슈에 관한 내용을 다룬다.
- 이 요건은 **쿠키를 이용한 사용자 추적, 식별**에 관한 내용을 담고 있으므로 쿠키를 오직 정보 저장의 용도로만 사용한다면 이 법령을 지킬 필요는 없다.
- 인증 세션과 함께 쿠키를 설정하거나 id를 추적하는 경우 사용자의 동의를 반드시 얻어야 하는데, 그 방법은 다음과 같다.
    1. 인증된 사용자에 대해서만 추적 쿠키를 설정하려는 경우

        가입 양식에 "개인 정보 취급 방침 동의" 같은 확인란을 만들고, 사용자가 동의할 경우에만 추적 쿠키를 설정

    2. 모든 사용자를 대상으로 추적 쿠키를 설정하려는 경우

        최초 방문자에게 쿠키 설정에 대한 동의를 얻는 "작은 창"을 보여주고 사용자가 동의한 경우에만 콘텐츠를 표시, 추적 쿠키를 설정한다. UX 측면에서는 나쁠 수 있으나, 이는 GDPR을 준수하기 위해서는 필수 사항이다.

<br>

### document.cookie

- `document.cookie` 프로퍼티를 이용하면 브라우저에서 쿠키에 접근할 수 있다.
- `document.cookie` 는 **name=value 쌍**으로 구성되어 있고, 각 쌍은 `;`로 구분한다. **쌍 하나는** **하나의 독립된 쿠키**를 나타낸다. 정규 표현식이나 배열 관련 함수를 사용하는 등 이 쌍을 분리해내면 원하는 쿠키를 찾을 수 있다.
- `document.cookie` 에 직접 값을 쓸 수 있다. 단, cookie는 프로퍼티 getter/setter를 이용해 구현되어 있는 **접근자 프로퍼티**이므로 데이터 프로퍼티에 값을 할당하는 것과는 다르게 처리된다. 쓰기는 **해당 쿠키의 값만 갱신**하고 다른 쿠키의 값은 변경하지 않는다.
- 쿠키 이름과 값에는 특별한 제약이 없기 때문에 모든 글자가 허용되나, 형식의 유효성을 일관되게 유지하기 위해 **반드시 내장 함수 `encodeURIComponent`를 사용하여 인코딩** 해야 한다.

<br>

### 쿠키 옵션

- 쿠키에는 몇 가지 옵션이 있는데, 몇몇 옵션은 아주 중요하기 때문에 반드시 지정해주어야 한다.
- `path=/`는 URL path의 접두사로, value는 절대 경로여야 한다. 기본값은 현재 경로이고, **설정한 경로나 그 하위 경로에서만 쿠키 정보를 볼 수 있다**. 특별한 경우가 아니라면 path 옵션을 루트로 설정해 웹사이트의 모든 페이지에서 쿠키에 접근할 수 있도록 하는 것이 좋다.
- `domain=site.com`는 옵션에 **아무런 값을 입력하지 않았다면** 쿠키를 설정한 도메인에서만 쿠키 정보를 얻을 수 있다. 정확히 해당 도메인에서만 쿠키 정보를 얻을 수 있는 것이므로 서브 도메인에서도 쿠키를 얻을 수 없도록 되어 있다.
**명시적으로 도메인 주소를 설정했다면** 해당 도메인의 서브 도메인에서도 쿠키 정보를 얻을 수 있다. 하위 호환성 유지를 위해 `domain=.site.com`과 같이 도메인 앞에 `.`을 붙인 표기를 하기도 하는데, 오래된 표기법이지만 **구식 브라우저를 지원하려면 이 표기법**을 사용하는 것이 좋다.
- `expires`와 `max-age` 는 쿠키의 만료 시간을 정해준다. 이런 쿠키를 **세션 쿠키**라고 부른다. 이 옵션이 없으면 브라우저가 닫힐 때 쿠키도 함께 삭제된다.
`expires`에는 쿠키 **만료 일시**를 설정한다. 쿠키의 유효 일자는 `date.toUTCString`을 사용하여 **GMT 포맷**으로 설정해야 한다. value를 과거로 지정하면 쿠키가 삭제된다.

    `max-age`는 expires 옵션의 대안으로 쿠키 **만료 기간**을 설정한다. 현재로부터 설정하고자 하는 만료 일시까지의 시간을 **초로 환산**한 값을 설정한다. value를 0이나 음수값으로 설정하면 쿠키가 삭제된다.

- `secure`는 HTTPS 연결에서만 쿠키를 사용할 수 있게 한다. `secure` 옵션이 설정되어 있지 않으면 HTTPS에서 설정(생성)한 쿠키를 HTTP에서 읽을 수 있고, 그 반대도 가능하다. **쿠키는 기본적으로 도메인만 확인**하고 프로토콜을 따지지 않기 때문이다. `secure`가 설정되어 있으면 HTTPS에서 설정한 쿠키를 HTTP에서 접근할 수 없다.
- `samesite`는 요청이 외부 사이트에서 일어날 때 브라우저가 쿠키를 보내지 못하도록 막아준다. [XSRF](https://ko.javascript.info/cookie#ref-747) 공격을 막는 데 유용하다. 단 오래된 브라우저(2017년 이전 버전)에서는 samesite 옵션을 지원하지 않으므로, **samesite 옵션으로만 보안 처리를 하지는 않도록** 해야 할 것이다. 구식 브라우저를 누구도 사용하지 않는 때가 오면 XSRF 토큰 없이 samesite 옵션만으로도 보안을 유지할 수 있을 것이다.
- `httpOnly` 옵션은 **웹서버에서 Set-Cookie 헤더를 이용해 쿠키를 설정할 때** 지정할 수 있다. 이 옵션은 JS같은 클라이언트 측 스크립트가 쿠키를 사용할 수 없게 하여(`document.cookie`로 쿠키 정보를 읽는 것조차 불가능하다.) 보안을 강화한다.

<br>

### **[서드 파티 쿠키](https://ko.javascript.info/cookie#ref-754)**

- 사용자가 방문 중인 도메인이 아닌 다른 도메인에서 설정한 쿠키를 **서드 파티 쿠키**라고 부른다.
- 단, **서드 파티 도메인에서 읽어온 스크립트가 `document.cookie`로 설정한 쿠키는 서드 파티 쿠키가 아니다.** 현재 페이지의 도메인에서 실행된 스크립트가 동일한 도메인에서 쿠키를 설정한 것이기 때문이다.
- 브라우저에 따라 서드 파티 쿠키를 허용하지 않을 수 있다. Safari는 기본적으로 서드 파티 쿠키를 금지하고 있고, FireFox는 서드 파티 도메인 블랙 리스트를 만들어 리스트에 오른 도메인의 서드 파티 쿠키를 차단한다. 구글 크롬도 [2022년까지 서드 파티 쿠키 지원을 중단하기로](https://www.bloter.net/newsView/blt202003240002) 하였다.

<br>

## localStorage와 sessionStorage

- 이 둘을 **웹 스토리지 객체**web storage object라고 부르며, 브라우저 내에 키-값 쌍을 저장할 수 있다. 키와 값은 반드시 문자열이어야 한다.
- 웹 스토리지 객체와 쿠키의 차이점, 웹 스토리지 객체를 이용하는 이유는 다음과 같다.
    - 웹 스토리지 객체는 **네트워크 요청 시 서버로 전송되지 않는다.** 따라서 쿠키보다 더 많은 자료를 보관할 수 있다. 대부분의 브라우저가 최소 **2MB 혹은 그 이상**의 웹 스토리지 객체를 저장할 수 있도록 구현되어 있다. ([브라우저별 저장 공간](https://en.wikipedia.org/wiki/Web_storage#Features)) 또한 개발자가 브라우저 내 웹 스토리지 구성 방식을 설정할 수도 있다.
    - 서버가 **HTTP 헤더를 통해 스토리지 객체를 조작할 수 없다.** 웹 스토리지 객체 조작은 모두 JS 내에서 수행된다.
    - 웹 스토리지 객체는 **도메인·프로토콜·포트**로 정의되는 오리진(origin)에 묶여 있다. 따라서 프로토콜과 서브 도메인이 다르면 데이터에 접근할 수 없다.
- 두 스토리지 객체는 Map과 유사하나 인덱스를 사용해 키에 접근할 수 있다는 점에서 차이를 보인다. 그러나 스토리지 객체는 **이터러블이 아니기 때문에 [배열처럼 다루어서 전체 키-값을](https://ko.javascript.info/localstorage#ref-925) 얻을 수 있다.**
- **storage 이벤트**는 setItem, removeItem, clear를 호출될 때 발생하는데, 이벤트가 생성된 곳을 제외하고 스토리지에 접근하는 모든 window 객체에서 일어난다.

<br>

### localStorage

- **오리진이 같은 경우 데이터가 모든 탭과 창에서 공유**된다. 오리진만 같으면 되기 때문에 url 경로가 달라도 동일한 결과를 볼 수 있다.
- 브라우저나 OS가 재시작하더라도 데이터가 파기되지 않는다.
- 일반 객체처럼 키를 설정하고 삭제하는 방식(`localStorage.customProperty = 1;` 처럼 사용하는 등)은 하위 호환성을 위해 지원되고 있기는 하지만 사용하지 않는 것이 좋다.

<br>

### sessionStorage

- 현재 떠 있는 **탭 내에서만 유지**된다. 같은 페이지라도 다른 탭에 있으면 다른 곳에 저장된다. (=오리진 뿐 아니라 브라우저 탭에도 종속되어 있다.) 그런데 **하나의 탭에 여러 개의 iframe이 있는 경우** 동일한 오리진에서 왔다고 취급되어 sessionStorage가 공유된다.
- **페이지를 새로고침 할 때**에는 sessionStorage가 사라지지 않는다. 그러나 **탭을 닫고 새로 열 때**에는 사라진다.
