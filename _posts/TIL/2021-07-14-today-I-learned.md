---
layout: post
title: "[TIL] 프라미스"
categories: [TIL]
tags: [TIL, JavaScript, asynchronous]
comment: true
---

# Today I Learned

2021/07/14

<br>

# 콜백 지옥과 프라미스

콜백 함수만을 이용하여 비동기 처리를 순서대로 처리하려 하다 보면 콜백이 또다른 콜백을 포함하게 된다. 처리할 동작이 적다면 이 방법도 나쁘지 않겠지만, 단계가 조금만 많아져도 비동기 동작이 꼬리에 꼬리를 물고 들어가면서 코드의 depth가 깊어지게 된다. 이렇게 깊은 중첩 코드가 만들어내는 패턴을 소위 **콜백 지옥** 혹은 **멸망의 피라미드**라고 부른다.

**프라미스(Promise)**는 이러한 콜백 지옥을 피하기 위해 고안된 방법 중 하나로, 콜백 함수만 사용할 때보다 가독성이 높고 그 결과를 원하는 만큼 체이닝하여 사용할 수 있다. 프라미스를 사용하면 보다 세련되고 편리하게 비동기 동작을 다룰 수 있다는 것이다.

명세와 사용법은 [이곳](https://ko.javascript.info/async)을 참고하여 공부하였다.

<br>

## 기본

- 프라미스 또한 객체이므로 `new` 를 통해 할당해야 한다.
- 프라미스에 인자로 전달되는 함수는 **executor**라고 부른다.
- **resolve**, **reject**는 executor에 기본으로 제공되는 자체 콜백이다. executor는 resolve나 reject 중 적어도 하나는 반드시 호출해야 한다.
    - reject를 호출할 때에는 **Error 객체** 또는 Error 객체를 상속받은 객체를 사용하는 것이 좋다.
- 프라미스 객체는 **state**, **result**라는 내부 프로퍼티를 갖는다. 이들은 내부 프로퍼티이므로 개발자가 직접 접근할 수 없으며 .then/.catch/.finally 메서드를 통하면 접근할 수 있다.
    - state: 초기에는 **pending**, resolve 호출 시 **fulfilled**, reject 호출 시 **rejected**
    - result: 초기에는 **undefined**, resolve(value) 호출 시 **value**, reject(error) 호출 시 **error**
- 처리되지 않은 프라미스는 **대기 프라미스**pending promise, resolve된 프라미스는 **이행된 프라미스**fulfilled promise, reject된 프라미스는 **거부된 프라미스**rejected promise라고 부르며 이 두 상태를 합쳐 **처리된 프라미스**settled promise라고 부른다.

<br>

## 소비 함수 (프라미스 핸들러)

- then, catch, finally 핸들러는 **항상 비동기적으로 실행**된다.
- then 메서드는 **처리된 프라미스 두 가지를 대상**으로 실행된다. 두 개의 콜백 함수를 인자로 받을 수 있는데, 첫 번째는 이행된 프라미스를 대상으로 하는 함수, 두 번째는 거부된 프라미스를 대상으로 하는 함수이다. 이 두 가지 콜백 함수는 **프라미스의 result를 각각 인자로** 받는다.
이행된 프라미스만 처리하고 싶을 경우 두 번째 인자를 생략하면 된다. 거부된 프라미스만 처리하고 싶을 경우 첫 번째 인자에 null을 넘겨주면 되는데, 그것보다는 .catch 메서드를 사용하는 편이 좋을 것 같다.
- catch 메서드는 **거부된 프라미스를 대상**으로 실행된다. 인자로 에러 발생 시 실행시킬 콜백 함수를 하나만 넘겨주면 된다. .then(null, handleError) 보다 문법적으로 간단하다는 사실을 제외하면 완벽하게 같은 동작을 한다.
- finally 메서드는 **처리된 프라미스 두 가지를 대상**으로 실행된다. .then(f, f) (=같은 콜백을 넘겨주는 경우)와 유사해 보이지만 다른 점이 있다. finally 메서드의 콜백 함수는 인자를 갖지 않는다. 이 메서드는 프라미스의 이행/거부 여부를 알 수 없으며, 그저 **프라미스가 처리된 경우 공통적으로 행할 동작**(로딩 UI 제거하기 등)을 정의하기 위해 쓰인다. 또, finally 핸들러는 자동으로 다음 핸들러에 result와 error를 전달한다.

<br>

## 프라미스 체이닝

- 하나의 프라미스에 then 핸들러를 여러 개 연결해 쓰는 것을 **프라미스 체이닝**이라 한다. then을 사용하면 프라미스가 반환되기 때문에 가능한 동작이다.
- 하나의 프라미스에 then을 여러 개 각각 연결하는 것은 프라미스 체이닝이 아니다.
- then 내부에서 프라미스를 생성하거나 반환할 수도 있다. 새로운 프라미스가 생성되어 반환되는 경우 체이닝 되어있는 다음 핸들러는 해당 프라미스가 처리될 때까지 대기하게 된다.
- **비동기 동작은 항상 프라미스를 반환하도록 하는 것이 좋다.** 그렇게 하면 당장은 사용하지 않더라도 후에 체인을 확장하고자 할 때 손쉽게 체인을 확장할 수 있다.

<br>

## 프라미스와 에러 핸들링

- 프라미스가 거부되는 경우 제어 흐름이 가장 가까운 rejection 핸들러로 넘어간다. 따라서 프라미스 체인을 사용하면 에러를 쉽게 처리할 수 있다.
- 체인에서 에러를 가장 쉽게 처리하는 방법은 프라미스 체인의 가장 끝에 .catch 핸들러를 붙이는 것이다. 그러면 위에 체이닝 되어있는 프라미스 중 하나라도 거부될 시 .catch가 에러를 잡아준다.
- 프라미스 executor와 핸들러 내부에서는 암시적 `try...catch`를 사용할 수 있다. 내부에서 throw를 사용할 시 `reject(new Error(...))`를 호출한 것과 같은 동작을 한다.
    - 단, executor가 실행되는 동안 throw한 에러만 잡을 수 있기 때문에 **executor 내부에서 비동기적으로 throw하면 catch가 트리거되지 않는다.**
    - catch에서도 더 처리할 수 없는 오류에 대한 처리를 하고 싶은 경우 내부에서 에러를 throw해주면 제어 흐름이 해당 체인에서 가장 가까운 catch로 다시 넘어가므로 정상 처리 되어야 할 부분의 동작을 뛰어넘고 에러 처리만 할 수 있다.
- **거부 상황에 대한 동작은 핸들러를 통해 반드시 처리**해야 하며, 그럼에도 처리하지 못한/처리되지 않은 예외의 경우 (브라우저 환경에서는) unhandledrejection 이벤트로 에러를 캐치할 수 있다.

<br>

## 프라미스 API

### Promise.all

- 프라미스의 배열(정확히는 이터러블 객체)을 인자로 받는다. 프라미스가 아닌 객체도 이 인자의 구성요소가 될 수 있는데, 이 경우 값이 결과에 그대로 전달된다.
- Promise.all이 정상 처리되면 **result의 배열을 반환**한다. 이 때 결과는 인자로 넘겨준 프라미스의 순서와 상응한다. 프라미스가 처리된 순서는 결과의 순서에 영향을 주지 않는다는 뜻이다.
- 넘겨준 프라미스 중 하나라도 거부되면 에러와 함께 즉시 거부된다. 이 경우 다른 프라미스는 계속 호출되기는 하지만 결과는 무시된다. 프라미스 API에는 프라미스를 취소할 수 있는 기능이 포함되어있지 않다. 거부 에러는 Promise.all 전체의 결과가 된다.

### Promise.allSettled

- 스펙에 추가된지 얼마 되지 않은 문법으로 구식 브라우저에서 사용 시 폴리필이 필요할 수 있다.
- 하나라도 거부되면 전부 거부되는 all과 다르게, allSetteled는 모든 프라미스가 처리될 때까지 기다린다. 모든 프라미스가 처리되고 나면 `{status:"fulfilled", value:result}`와 `{status:"rejected", reason:error}`로 이루어진 배열을 반환한다.

### Promise.race

- Promise.all과 같은 인자를 받되 가장 먼저 처리된 프라미스의 결과(혹은 에러)를 반환한다.

### Promise.resolve/reject

- 각각 특정 결과와 함께 이행된 프라미스, 특정 에러와 함께 거부된 프라미스를 반환한다. async/await의 등장 이후 거의 사용되지 않는다.

<br>

## 프라미스화

- 콜백을 받는 함수를 프라미스를 반환하는 함수로 바꾸는 것을 **프라미스화**promisification라고 한다.

<br>

## 마이크로태스크

**일반 태스크 큐(=매크로태스크 큐) vs 마이크로태스크 큐** ([참고 링크](https://ko.javascript.info/event-loop))

- ECMA에서는 PromiseJobs라는 내부 큐(=**잡 큐**)를 명시하고 있고, V8 엔진에서 이를 **마이크로태스크 큐**라고 부르기 때문에 이 용어를 널리 사용한다.
- 자바스크립트 엔진은 매크로태스크 하나를 처리하고 난 직후, **다른 매크로태스크나 렌더링 작업을 하기 전에** 마이크로태스크 큐에 있는 마이크로태스크 전부를 처리한다. 마이크로태스크 전체가 처리되는 동안에는 UI 변화나 네트워크 이벤트 핸들링이 일어나지 않는다.
- 위에서 언급한 '처리되지 못한 거부'는 **마이크로태스크 큐 끝에서 프라미스 에러가 처리되지 못할 때** 발생한다.

<br>

## async / await

- function 키워드 앞에 **async**를 붙이면 해당 함수는 항상 프라미스를 반환한다. 프라미스가 아닌 값을 반환하더라도 해당 값을 결과로 가지는 이행된 프라미스를 반환한다.
    - 메서드 이름 앞에 async를 추가하면 클래스 메서드도 async로 사용할 수 있다.
- **await**는 async 함수 내부에서만 동작한다. await 키워드를 프라미스 객체와 함께 사용하면 프라미스가 처리될 때까지 다른 처리를 하지 않고 해당 라인에서 대기한다. 단, 이 처리를 기다리는 동안에도 엔진이 다른 일(다른 스크립트 실행, 이벤트 처리 등)을 하기 때문에 CPU 리소스가 낭비되지는 않는다.
    - await는 async로 감싸져야 하기 때문에 최상위 레벨(전역 스코프)에서 사용하고 싶다면 익명 async 함수로 감싸주어야 한다.
    - await도 promise.then처럼 thenable 객체를 받는다.
    - Promise.all의 결과도 await로 기다릴 수 있다.
- await를 사용했을 때 프라미스가 거부되면 **에러 객체를 throw한 것처럼 처리**된다. 따라서 await를 사용할 때에는 await가 포함된 코드를 try...catch문을 사용해주거나, async에서 반환된 프로미스에 .catch 핸들러를 추가해주어야 한다.

