---
layout: post
title: "[C++] 복사 생성자와 복사 대입 연산자"
categories: [STUDY, STUDY/CPP]
tags: [C++, Effective C++]
---
💡 **기본적인 개념, 사용법에 대한 글이 아닙니다. Effective C++을 읽으며 기억해둘 만한 부분을 정리한 글입니다. 개념을 익힌 뒤 읽어보시면 좋습니다.**

<br>
-   컴파일러는 경우에 따라 클래스에 대해 기본 생성자, 복사 생성자, 복사 대입 연산자, 소멸자를 암시적으로 만들 수 있다.
-   어떤 시그니처를 가졌든 클래스 내부에 생성자를 직접 선언하면 컴파일러는 기본 생성자를 만들지 않는다. 따라서 기본 생성자가 필요 없다면 원하는 인자를 받는 생성자를 직접 만들어주기만 하면 된다.
-   컴파일러가 암시적으로 만들어내는 복사 생성자 및 복사 대입 연산자는 **아래**와 같은 경우 컴파일을 거부한다. 단순히 일괄 복사(대입) 처리 하는 것만으로는 해결할 수 없는 데이터 멤버가 있을 때, 암시적으로 만들어지는 복사 대입 연산자가 이런 경우의 처리 방법까지 판단하여 작업해야 할 이유가 없다. 따라서 해당 데이터 멤버에 대한 처리를 보류하고 컴파일 오류를 보여주는 것이라 보면 된다. 이런 경우 직접 복사 대입 연산자를 정의하고 사용해야 한다.

```cpp
class NamedObject {
public:
    NamedObject(std::string& name, const int& value);
    ...
private:
    std::string& nameValue; // 참조자의 참조 대상은 한 번 정해지면 바꿀 수 없다.
    const int objectValue; // 상수 멤버의 값을 변경할 수 없다.
};
```

-   복사 대입 연산자를 private으로 선언한 기본 클래스로부터 상속받은 클래스의 경우, 파생 클래스는 암시적 복사 대입 연산자를 가질 수 없다. 파생 클래스가 기본 클래스의 복사 대입 연산자를 호출할 권한이 없기 때문이다.
    

-   파생 클래스의 복사 생성자에서는 반드시 기본 클래스의 복사 생성자도 호출해준다. 주어진 객체의 모든 데이터 멤버 및 모든 기본 클래스 부분을 빠뜨리지 않고 복사해야 한다. 같은 이유로, 파생 클래스의 복사 대입 연산자에서는 반드시 기본 클래스의 복사 대입 연산자도 호출해준다.
    

```cpp
class DerivedClass : public BaseClass {
public:
    ...
    DerivedClass& operator=(const DerivedClass& rhs)
    {
        if (this != &rhs)
        {
            BaseClass::operator=(rhs);
                // 기본 클래스 부분에 대한 대입 연산자를 반드시 호출한다.
            ... // 이하 파생 클래스의 데이터 멤버 대입
        }
        return *this;
    }
    ...
};
```

-   복사 생성자와 복사 대입 연산자가 서로를 사용하지 않도록 한다.
    -   **복사 대입 연산자에서 복사 생성자를 호출하는 경우**: 애초에 말도 안 되는 방식이니 상상도 하지 말자.
    -   **복사 생성자에서 복사 대입 연산자를 호출하는 경우**: 생성자의 역할은 새로 만들어진 객체를 초기화하는 것, 대입 연산자의 역할은 '이미' 초기화가 끝난 객체에 값을 주는 것. 초기화 되지 않은 객체에 값을 대입하는 연산자를 사용하지 않아야 한다.
    -   단, 복사 생성자와 복사 대입 연산자의 코드 본문이 비슷하다면 겹치는 부분을 별도의 private 멤버 함수로 분리해 만든 뒤 해당 함수를 호출하게 만든다. 이 방법은 안전할 뿐 아니라 검증된 방법이므로 코드 중복 제거를 위해 사용해봄직하다.

-   복사 대입 연산자가 **자기대입에 대한 처리 및 예외에 대한 안전성**을 확보할 수 있도록 하는 방법이 있다. 자기대입은 흔히 일어나는 일이 아니므로 operator=가 호출될 때마다 일치성 검사를 수행하는 것 또한 비효율적인 동작이 된다. 따라서 아래처럼 operator=를 작성하면 자기대입에 대해 특별한 처리를 하지 않아도 되고, 예외 안전성까지 확보할 수 있다.

```cpp
// (1)
DerivedClass& DerivedClass::operator=(const DerivedClass &rhs)
{
    BaseClass *pOrig = p;      // 원본 p의 포인터를 저장해둔다.
    p = new BaseClass(*rhs.p); // rhs.p를 통해 BaseClass의 복사 생성자를 부른다.
                                // new에서 예외가 발생해도 원본 p는 무사하다.
    delete pOrig;

    return *this;
}

// (2) 복사 후 맞바꾸기 방법
class Widget {
    ...
    void swap(Widget& rhs); // *this의 데이터와 rhs의 데이터를 맞바꾸는 함수
    ...
}

Widget& Widget::operator=(const Widget& rhs)
{
    Widget temp(rhs);  // rhs의 데이터에 대한 사본을 만든다.
    
    swap(temp);        // Widget::swap 함수를 통해 데이터를 바꾼다.
                        // temp는 지역 객체이므로 함수가 끝날 때 자동 소멸된다.
    return *this;
}
```

<br>
### Reference

-   스콧 마이어스 지음, 곽용재 옮김, "Effective C++," 제3판.
    -   항목 5: C++가 은근슬쩍 만들어 호출해 버리는 함수들에 촉각을 세우자, 81.
    -   항목 11: operator=에서는 자기대입에 대한 처리가 빠지지 않도록 하자, 106.
    -   항목 12: 객체의 모든 부분을 빠짐없이 복사하자, 111.
